;J=id ecran
:init_ecran
ife [nb_ecrans],1
	set pc,pop
add [nb_ecrans],1
set push,A
set push,Z
set [id_ecran],J
set a,[ecran_taille]
jsr malloc
ife Z,0xFFFF
	set pc,end
set [VRAM1],z
set [ecran_actif],z
jsr malloc
ife Z,0xFFFF
	set pc,end
set [VRAM2],Z
set Z,pop
set A,pop
set pc,update_vram


;b=pointeur font,0=default
:change_font
	set push,A
	set a,1
	hwi [id_ecran]
	set A,pop
	set pc,pop

;b=couleur, aucun controle sur b
:change_couleur
set [couleur] , B
set pc , pop

;b=pointeur palette,0=default
:change_palette
	set push,A
	set a,2
	hwi [id_ecran]
	set A,pop
	set pc,pop

;b=color (0-F)
:change_bordure
	set push,A
	set a,3
	hwi [id_ecran]
	set A,pop
	set pc,pop

;pointeur en z,0xFFFF si plus de place
:get_font
	set push,A
	set a,256
	jsr malloc
	ife z,0xFFFF
		set pc,gf_end
	set a,4
	set b,z
	hwi [id_ecran]
	:gf_end
	set A,pop
	set pc,pop

;pointeur en z,0xFFFF si plus de place
:get_palette
	set push,A
	set a,16
	jsr malloc
	ife z,0
		set pc,gf_end
	set a,5
	set b,z
	hwi [id_ecran]
	:gp_end
	set A,pop
	set pc,pop

;pointeur en z
:get_vram
	set z,[ecran_actif]
	set pc,pop

;pointeur en b, 0=default
:set_vram
	ife b,0
		set b,[VRAM1]
	set [ecran_actif],b
	set pc,update_vram


;routine interne
:update_vram
	set push,A
	set push,B
	set a,0
	set b,[ecran_actif]
	hwi [id_ecran]
	set B,pop
	set A,pop
	set pc,pop

;-----------------------------------------
;EFFACE LIGNE
;Ligne stockée dans I (de 1 à 12)
;Si I > 12, I = 12
;-----------------------------------------
:efface_ligne
set push , i
set push , j
ifg i , 12
	set i , 12
sub i , 1
mul i , 32
add i , [ecran_actif]
set j , 0
.boucle_efface_ligne
sti [I],0
sti [I],0
sti [I],0
sti [I],0
sti [I],0
sti [I],0
sti [I],0
sti [I],0
ifn J,32
	set pc,boucle_efface_ligne
set j , pop
set i , pop
set pc , pop



;-------------------------------------------
;SCROLL D'UNE LIGNE VERS LE HAUT
;LA LIGNE EST STOCKEE DANS I
;SI I > 12 , I = 12
;SI I = 1 , rien à faire
;-------------------------------------------

:scroll
set push , i
set push , j
set push , x
set push , y
ife i , 1
	set pc , fin_scroll
ifg i , 12
	set i , 12
sub i , 1
set j , i
sub j , 1
mul i , 32
mul j , 32
add i , [ecran_actif]
add j , [ecran_actif]
set x , 0
set y , 0x9F
BOR y , [couleur]
	:boucle_scroll
	ife x , 32
		set pc , fin_scroll
	ife [i] , y
		set pc , fin_scroll
	sti [j] , [i]
	add x , 1
	set pc , boucle_scroll
:fin_scroll
set y , pop
set x , pop
set j , pop
set i , pop
set pc , pop

;---------------------------------
;SCROLL ECRAN
;REMONTE TOUT D'UNE LIGNE
;ET EFFACE DERNIERE LIGNE (12)
;---------------------------------
:scroll_ecran
set push , I
set I , 12
JSR scroll_from
set I , pop
set pc , pop


;-------------------------------
;Scroll du haut jusqu'a la ligne scpécifiee
;Ligne dans I
;-------------------------------

:scroll_from
set push , i
set push , j
set j , I
set i , 2
:boucle_scroll_from
ifg i , j
	set pc , fin_scroll_from
JSR scroll
add i , 1
set pc , boucle_scroll_from
:fin_scroll_from
set I , J
JSR efface_ligne
set j , pop
set i , pop
set pc , POP

;--------------------------------
;Afficher une phrase à l'écran
;Ligne dans I , 1 < I < 12
;Colonne dans J , 1 < J < 32
;Adresse de du texte dans A
;--------------------------------
:printf
set push,B
set push,I
set push,J
set push,X
ifl i,1
	set I,1
ifg I,12
	set I,12
ifl J,1
	set J,1
ifg J,32
	set J,32
sub I,1
sub J,1
set I,I
mul I,32
add I,J
add I,[ecran_actif]
set J,A
add [ecran_taille],[ecran_actif]
:boucle_printf
set B,[J]
ife B,0
	set pc,fin_printf
ife I,[ecran_taille]
	JSR scroll_printf
ife B,0x11
	set pc,p_return
ife B,0x1F
	set pc,p_tab	
BOR B,[COULEUR]
sti [I],B
set pc , boucle_printf
:fin_printf
sub [ecran_taille],[ecran_actif]
set X,pop
set J,pop
set I,pop
set B,pop
set pc,pop

:scroll_printf
JSR scroll_ecran
sub I,32
set pc , pop

;------------------------------
;AJOUT DE BLANC TANT QU'ON EST
;PAS EN DEBUT DE LIGNE (plus vraiment maintenant... :p)
;------------------------------

:p_return
set X,I
sub X,[ecran_actif]
mod X,32
add I,32
sub I,X
add J,1
set pc,boucle_printf



;--------------------------------------
;AJOUT DE 3 BLANCS OU RETOUR A LA LIGNE
;--------------------------------------
:p_tab
set X,I
sub X,[ecran_actif]
mod X,32
ifg X,29
	set pc , ptab1
set [I],0
add I,1
set [I],0
add I,1
set [I],0
add I,1
set pc,fin_ptab
:ptab1
ife X,32
	set pc,fin_ptab
add X,1
set [I],0
add I,1
set pc,ptab1
:fin_ptab
add J,1
set PC,boucle_printf

;-------------------------------------
;CLEAR the screen
;-------------------------------------
:clear
set push,A
set A,[ecran_actif]
jsr efface_memoire
set A,pop
set PC,pop


;------------------------------
;AFFICHER UN CARACTERE
;CARACTERE DANS C
;I , ligne
;J , colonne
;-----------------------------
:printc
set push,I
set push,J
set push,C
ifl i , 1
	set i , 1
ifg i , 12
	set i , 12
ifl j , 1
	set j , 1
ifg j , 32
	set j , 32
sub i , 1
sub j , 1
mul i , 32
add i , j
add i , [ecran_actif]
BOR c , [couleur]
set [i] , c
set C,pop
set J,pop
set I,pop
set pc , pop

;-------------------------
;Bascule de l'ecran
;Console <-> Appli
;-------------------------
:ecran_bascule_ecran
ife [ecran_actif], [VRAM1]
	set pc , ecran_bascule_ecran_2
ife [ecran_actif],[VRAM2]
	set pc , ecran_bascule_ecran_1
:ecran_bascule_ecran_1
set [FOCUS_CLAVIER] , 0x1
set [ecran_actif] , [VRAM1]
set pc , fin_ecran_bascule_ecran
:ecran_bascule_ecran_2
set [FOCUS_CLAVIER] , 0x2
set [ecran_actif] , [VRAM2]
:fin_ecran_bascule_ecran
set push , A
set push , B
set A , 0
set B , [ecran_actif]
hwi [id_ecran]
set b , pop
set a , pop
set pc , pop



