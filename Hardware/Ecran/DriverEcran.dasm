;J=id ecran
:init_ecran
ife [nb_ecrans],1
	set pc,pop
add [nb_ecrans],1
set [id_ecran],J
set pc,pop

;b=pointeur font,0=default
:change_font
	set push,A
	set a,1
	hwi [id_ecran]
	set A,pop
	set pc,pop

;b=couleur, aucun controle sur b
:change_couleur
set [couleur] , B
set pc , pop

;b=pointeur palette,0=default
:change_palette
	set push,A
	set a,2
	hwi [id_ecran]
	set A,pop
	set pc,pop

;b=color (0-F)
:change_bordure
	set push,A
	set a,3
	hwi [id_ecran]
	set A,pop
	set pc,pop

;pointeur en z,0xFFFF si plus de place
:get_font
	set push,A
	set a,256
	jsr malloc
	ife z,0xFFFF
		set pc,gf_end
	set a,4
	set b,z
	hwi [id_ecran]
	:gf_end
	set A,pop
	set pc,pop

;pointeur en z,0xFFFF si plus de place
:get_palette
	set push,A
	set a,16
	jsr malloc
	ife z,0
		set pc,gf_end
	set a,5
	set b,z
	hwi [id_ecran]
	:gp_end
	set A,pop
	set pc,pop

;pointeur en z
:get_vram
	set z,[ecran_actif]
	set pc,pop

;pointeur en b
:set_vram
	set [ecran_actif],b
	set pc,update_vram


;routine interne
:update_vram
	set push,A
	set push,B
	set a,0
	set b,[ecran_actif]
	hwi [id_ecran]
	set B,pop
	set A,pop
	set pc,pop

;-----------------------------------------
;EFFACE LIGNE
;Ligne stockée dans I (de 1 à 12)
;Si I > 12, I = 12
;-----------------------------------------
:efface_ligne
set push , i
set push , j
ifg i , [ecran_h]
	set i , [ecran_h]
sub i , 1
mul i , [ecran_w]
add i , [ecran_actif]
set j , 0
:boucle_efface_ligne
sti [I],0
sti [I],0
sti [I],0
sti [I],0
sti [I],0
sti [I],0
sti [I],0
sti [I],0
ifn J,[ecran_w]
	set pc,boucle_efface_ligne
set j , pop
set i , pop
set pc , pop

;---------------------------------
;SCROLL ECRAN
;REMONTE TOUT D'UNE LIGNE
;ET EFFACE DERNIERE LIGNE (12)
;---------------------------------
:scroll_ecran
set push,A
set push,B
set push,C
set push,I
set A,[ecran_actif]
set B,A
add B,[ecran_w]
set C,[ecran_taille]
sub C,[ecran_w]
jsr memcpy
set I,12
jsr efface_ligne
set I,pop
set C,pop
set B,pop
set A,pop
set pc , pop

;--------------------------------
;Afficher une phrase à l'écran
;Ligne dans I , 1 < I < 12
;Colonne dans J , 1 < J < 32
;Adresse de du texte dans A
;--------------------------------
:printf
set push,B
set push,I
set push,J
set push,X
set push,Y
ife [A],0
	set pc,fin_printf
ifl i,1
	set I,1
ifg I,[ecran_h]
	set I,[ecran_h]
ifl J,1
	set J,1
ifg J,[ecran_w]
	set J,[ecran_w]
sub I,1
sub J,1
mul I,[ecran_w]
add I,J
add I,[ecran_actif]
set J,A
set Y,[ecran_taille]
add Y,[ecran_actif]
:boucle_printf
set B,[J]
ife I,Y
	jsr scroll_printf
ifl B,0x20
	set pc,choix_printf
BOR B,[COULEUR]
sti [I],B
ifn [J],0
	set pc , boucle_printf
:fin_printf
set Y,pop
set X,pop
set J,pop
set I,pop
set B,pop
set pc,pop
:choix_printf
ife B,0x11
	set pc,p_return
ife B,0x1F
	set pc,p_tab
add J,1
set pc,boucle_printf

:scroll_printf
JSR scroll_ecran
sub I,[ecran_w]
set pc , pop

;------------------------------
;un \n sans ajout de blanc
;------------------------------

:p_return
set X,I
sub X,[ecran_actif]
mod X,[ecran_w]
add I,[ecran_w]
sub I,X
add J,1
ifl I,Y
	ifn I,Y
		set pc,boucle_printf
jsr scroll_ecran
sub I,[ecran_w]
set pc,boucle_printf



;--------------------------------------
;un \t (sans ajout de blanc)
;--------------------------------------
:p_tab
add I,3
add J,1
ifl I,Y
	ifn I,Y
		set pc,boucle_printf
jsr scroll_ecran
sub I,[ecran_w]
set PC,boucle_printf

;-------------------------------------
;CLEAR the screen
;-------------------------------------
:clear
set push,A
set A,[ecran_actif]
jsr efface_memoire
set A,pop
set PC,pop


;------------------------------
;AFFICHER UN CARACTERE
;CARACTERE DANS C
;I , ligne
;J , colonne
;-----------------------------
:printc
set push,I
set push,J
set push,C
ifl i , 1
	set i , 1
ifg i , [ecran_h]
	set i , [ecran_h]
ifl j , 1
	set j , 1
ifg j , [ecran_w]
	set j , [ecran_w]
sub i , 1
sub j , 1
mul i , [ecran_w]
add i , j
add i , [ecran_actif]
BOR c , [couleur]
set [i] , c
set C,pop
set J,pop
set I,pop
set pc , pop
