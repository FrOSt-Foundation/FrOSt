;*************************
; Project: FrOSt
; File: DriverSPED.dasm
;*************************

.define STATE_NO_DATA   0
.define STATE_RUNNING   1
.define STATE_TURNING   2

.define ERROR_NONE     0
.define ERROR_BROKEN   0xffff

:sped_buffer_begin		dat 0x0000
:sped_buffer_capacity	dat 0x0000

:sped_angle				dat 0x0000

;-----------------------------------------------;
;					Sorties						;
;-----------------------------------------------;

; Interroge le SPED-3 sur son état.
; return B = état actuel
; return C = dernière erreur
:sped_pollState
	set PUSH, A

	set A, 0
	hwi [id_sped]

	set A, POP
	set PC, POP

; Attend jusqu'à la fin de la rotation en cour
:sped_waitForStaticState
	set PUSH, A
	set A, 0
	:sped_waitForStaticState_loop1
		hwi [id_sped]
		ife B, 2
			set PC, sped_waitForStaticState_loop1
	set A, POP
	set PC, POP

;-----------------------------------------------;
;				Configuration					;
;-----------------------------------------------;

; Définit les variables du buffer du SPED-3
; X = Adresse de début du buffer
; Y = Adresse de fin du buffer
:sped_setBuffer_data
	set PUSH, Y
	
	sub Y, X
	div Y, 2
	set sped_buffer_begin, X
	set sped_buffer_capacity, Y
	
	set Y, POP
	set PC, POP 

; Définit les variables du buffer du SPED-3
; X = Adresse de début du buffer
; Y = Nombre de points contenu dans le buffer
:sped_setBuffer_point
	set sped_buffer_begin, X
	set sped_buffer_capacity, Y
	
	set PC, POP


;-----------------------------------------------;
;					Commandes					;
;-----------------------------------------------;


; Remet le SPED dans son état à l'allumage.
:sped_reinit
	set PUSH, A
	set PUSH, B
	set PUSH, C
	set PUSH, X
	set PUSH, Y

	; On réinitialise l'angle du sped à 0
	set A, 2
	set X, 0
	hwi [id_sped]
	
	set sped_angle, 0

	; On attend que la rotation se termine.
	set A, 0
	:sped_reinit_loop1
		hwi [id_sped]
		ife B, 2
			set PC, sped_reinit_loop1

	; On affiche rien
	set A, 1
	set Y, 0
	hwi [id_sped]
	
	set sped_buffer_begin, 0
	set sped_buffer_capacity, 0

	set Y, POP
	set X, POP
	set C, POP
	set B, POP
	set A, POP
	set PC, POP

; Met à jour le SPED selon les variables
; X = Paramètre de sécurité, voir sped_rotate
:sped_update
	set PUSH, A
	set PUSH, X
	set PUSH, Y
	
	set Y, X
	set X, sped_angle
	jsr sped_rotate
	
	set A, 1
	set X, sped_buffer_begin
	set Y, sped_buffer_capacity
	hwi [id_sped]
	
	set Y, POP
	set X, POP
	set A, POP
	set PC, POP

; Affiche le buffer
:sped_printBuffer
	set PUSH, A
	set PUSH, X
	set PUSH, Y
	
	set A, 1
	set X, sped_buffer_begin
	set Y, sped_buffer_capacity
	hwi [id_sped]
	
	set Y, POP
	set X, POP
	set A, POP
	set PC, POP

; Efface l'écran du SPED-3.
:sped_clear
	set PUSH, A
	set PUSH, Y

	set A, 1
	set Y, 0
	hwi [id_sped]

	set Y, POP
	set A, POP
	set PC, POP

; Tourne l'affichage
; X = Nombre de degrés de la rotation
; Y = Paramètre de sécurité, 0: passer si déjà en train de tourner, 1: attente début, 2: attente fin, 3: attente debut et fin
.define SPED_ROTATE_SKIP_IF_TURNING		0
.define SPED_ROTATE_WAIT_BEGIN			1
.define SPED_ROTATE_WAIT_END			2
.define SPED_ROTATE_WAIT_BOTH			3

:sped_rotate
	set PUSH, A
	set PUSH, B

	set A, 0
	ifn Y, 0
		set PC, sped_rotate_skip1
		
		hwi [id_sped]
		ife B, 0
			set PC, sped_rotate_skip3
		set PC, sped_rotate_skip2
		
	:sped_rotate_skip1
	
	ife Y, 2
		set PC, sped_rotate_skip2

		:sped_rotate_loop1
			hwi [id_sped]
			ife B, 2
				set PC, sped_rotate_loop1

	:sped_rotate_skip2
	
	set A, 2
	hwi [id_sped]
	
	ifl Y, 2
		set PC, sped_rotate_skip3

	set A, 0
	:sped_rotate_loop2
		hwi [id_sped]
		ife B, 2
			set PC, sped_rotate_loop2

	:sped_rotate_skip3
	
	set sped_angle, X
	
	set B, POP
	set A, POP
	set PC, POP

; Même chose que la fonction précédente, mais ne vérifie pas les paramètres et
; n'attend pas que la rotation soit effectuée.
:sped_rotate_unsafe
	set PUSH, A

	set A, 2
	hwi [id_sped]
	
	set sped_angle, X

	set A, POP
	set PC, POP
