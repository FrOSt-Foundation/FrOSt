; *************************
; Project: FrOSt
; File: commands.dasm
; *************************

:launch_echo
	;Affichage de l'argument (le texte)
	set B, Y
	int 0x1000
	
	set PC, POP
	
:launch_help
	;Affichage des commandes
	set B, msg_help
	int 0x1000
	
	set PC, POP
	
:launch_about
	set B, msg_about
	int 0x1000
	
	set PC, POP
	
:launch_color
	set A, Y
	ife [A],0
		set pc,pop
	set B, 16
	jsr ctoi
	and Z,0xFF00 ;on garde seulement ce qui colore
	set B, Z
	int 0x2000
	set PC, POP
	
:launch_clear
	int 0x2004
	set PC, POP
	
:launch_kill
	set A, Y
	set B, 10
	jsr ctoi
	ife [A], 0
		set PC, launch_kill_errNoArgs
	set A, Z
	
	;On a en A l'ID du programme à tuer, reste à implémenter la fonction.
	
	set B, msg_todo
	int 0x1000
	
	set PC, POP
	
	:launch_kill_errNoArgs
		set B, msg_errNoArgs
		set J, 1
		int 0x1000
		set PC, POP
	
:launch_ls
	jsr FFAT16_listFiles
	;TODO : Afficher tout ça et ne pas oublier le free de mémoire
	
	set B, msg_ls
	set J, 0
	int INT_PRINTF
	
	set A, Y
	set B, 10
	set C, mem_print
	jsr dump
	
	set B, mem_print
	set J, 22
	int INT_PRINTF
	
	set PUSH, Z
		set X, Z
		;Allocation d'un buffer de 15 mots (14 pour le nom de fichier et 1 pour la fin de chaine)
		set B, 15
		int INT_MALLOC
		IF_MALLOC_ERROR
			set PC, launch_ls_break0
		set PUSH, Z
		add Z, 14
		set [Z], 0
		set Z, PEEK
		;À ce stade :
		; X = adresse du tableau
		; Y = Nombre de fichiers
		; Z = Adresse du buffer
		set PUSH, 0
		:launch_ls_loop0
			int INT_SCROLL
			set B, X
			set A, Z
			set C, 14
			jsr memcpy
			set B, Z
			set I, 12
			set J, 0
			int INT_PRINTF
			
			add X, 14
			
			set J, POP
			add J, 1
			set PUSH, J
			ifn J, Y
				set PC, launch_ls_loop0
		set J, POP
		set B, POP
		int INT_FREE
	:launch_ls_break0
	set B, POP
	int INT_FREE
	
	set PC, POP
	
:launch_cd
	set B, msg_todo
	int 0x1000
	
	set PC, POP
	
:launch_run
	set B, msg_todo
	int 0x1000
	
	set PC, POP

:launch_mem
	set A, [free_mem]
	set B, 16
	set C, mem_print
	jsr dump
	
	set B, msg_mem
	int 0x1000
	
	add J, 18
	set B, mem_print
	int 0x1000
	
	set PC, POP
	
:launch_mkdir
	set B, msg_todo
	int 0x1000
	
	set PC, POP
	
:launch_mv
	set B, msg_todo
	int 0x1000
	
	set PC, POP
	
:launch_cp
	set B, msg_todo
	int 0x1000
	
	set PC, POP
	
:launch_touch
	set B, msg_todo
	int 0x1000
	
	set PC, POP
		
	
:launch_cat
	set B, msg_todo
	int 0x1000
	
	set PC, POP
	
:launch_ps
	set Z, process
	ife [Z], 0
		set PC, POP
	set PUSH, I
	set PUSH, J
	set I, mem_print
	set J, 0
	
	:launch_ps_loop2
		sti [I], 0
		ifn 4, J
			set pc, launch_ps_loop2
			
	set J, POP
	set I, POP
	set B, 10
	:launch_ps_loop1
		set C, mem_print
		set X, [Z]
		set A, [X]
		jsr dump
		
		set B, mem_print
		int 0x1000
		
		set B, 10
		add J, 7
		set A, [X + 1]
		
		set C, mem_print
		jsr dump
		
		set B, mem_print
		int 0x1000
		
		set B, [X + 2]
		add J, 7
		int 0x1000
		add Z, 1
		ifn Z, counter
			ifn	[Z], 0
				set pc, launch_ps_loop1	
	set PC, POP

:launch_test
	set B, msg_testprog
	int 0x1000
	jsr testprog
	
	set PC, POP

:launch_shutdown
	set B,0
	jsr lem1802_setVram
	jsr clock_setSpeed
	set PC,end
	
:launch_format
	set B, msg_confirmFormat
	int INT_PRINTF
	
	:launch_format_loop0
		int INT_WAITKEY_NOTBLOCKING
		ifn C, 0
			ifn C, 0x79
				set PC, POP
		ife C, 0
			set PC, launch_format_loop0
		
	jsr FFAT16_format
		
	set PC, POP
	
:launch_diskinf
	set B, msg_diskInf
	int INT_PRINTF
	
	; COMPATIBLE
	; ----------
	set C, '0'
	IF_TRUE [FFAT16_VALID]
		set C, '1'
	set I, 10
	set J, 20
	int 0x1001
	
	set B, volumeName
	set I, 11
	set J, 15
	int INT_PRINTF
	
	; SERIAL NUMBER
	; -------------
	
	set A, [serialNumber]
	set B, 16
	set C, mem_print
	jsr dump
	
	set B, mem_print
	set I, 12
	set J, 17
	int INT_PRINTF
	
	set A, serialNumber
	add A, 1
	set A, [A]
	set B, 16
	set C, mem_print
	jsr dump
	
	set B, mem_print
	set I, 12
	set J, 22
	int INT_PRINTF
	
	set PC, POP
		
