; *************************
; Project: FrOSt
; File: input.dasm
; *************************

:console_readLine	
	set J, 3 ;Adresse du caractere sur la ligne
	;Initialisation de la mémoire
	set X,0
	set B, pick 3
	int 0x0002
	set B,pick 2
	int 2
	set B,pick 1
	int 2	
	:console_readLine_loop
		int 0x4001 ;Attente que un caractère soit tapé. Celui-ci sera enregistré en C.
		ife C, 0
			set pc, console_readLine_loop
		set PC, console_processChar	
	
:console_processChar
	ife C, 0x11 ;Return
		set PC, console_processCommand
	ife C, 0x10 ;Backspace
		set PC, console_backspace
	ifg C,0x79
		ifl C,0x84
			set pc,console_arrows
	ife J, 32 ;Si on est a la fin de la ligne, on ne fait rien ^^
		set PC, console_readLine_loop
	;Si aucune des conditions ci-dessus n'est remplie, alors on affiche le caractere.
	;set I, SCREEN_HEIGHT ;On affichera le caractère à la dernière ligne.
	int 0x1001 ;printc
	
	sub J, 3 ;On enleve les deux caractères de J nécessaires à faire un affichage correct à l'écran
	
	;set [Z + J], C ne marche pas, il y a trop de registres pour DevCPU.
	add B, J
	set [B], C
	sub B, J
	
	add J, 4 ;Puis on remet ces 2 caractères plus un autre puisque on vient de taper un caratère ^^
	set C,0x220
	int 0x1001
	set PC, console_readLine_loop

:console_arrows_define
set X,J
add X,1
set pc,pop
:console_arrows
set A,C
sub J,3
add B,J
set C,[B]
ife C,0
	set C,0x20
sub B,J
add J,3
int 0x1001
ifg J,X
	jsr console_arrows_define
ife A,KBD_ARROW_LEFT
	sub J,1
ife A,KBD_ARROW_RIGHT
	add J,1
ife J,X
	sub J,1
ife J,2
	add J,1
sub J,3
add B,J
set C,[B]
ife C,0
	set C,0x20
sub B,J
add J,3
set B,0x200
jsr change_couleur
int 0x1001
set B,0x2000
jsr change_couleur
set B,pick 1
set pc,console_readLine_loop
:console_processCommand
	
	; --------------
	; Parser
	; --------------
	set C,0x20
	int 0x1001 ;on vire le carré à la fin de la chaîne.
	
	;On peek I,J.
	set I, pick 1
	set J,pick 2
	;attention, ne vérifie pas s'il y a des espaces au début.
	:console_processCommand_loop
		sti [J],[I]
		ifg [I], 0x21 ;Si on tombe sur l'espace ou \t ou \n ou \0, on quitte la boucle
			set PC, console_processCommand_loop
	
	:console_processCommand_endLoop
	add I, 1
	set J,pick 3
	set Z,I
	sub Z,pick 1
	ifg Z,0x30
		set pc,launcher ;on vérifie qu'on fait pas un buffer overflow
	;On copie les arguments en Y maintenant
	:console_processCommand_loop2
		sti [J],[I]
		ifn [I], 0x0 ;On ne veut s'arrêter QUE si on est à la fin, on prend tous les arguments en une seule chaine.
			set PC, console_processCommand_loop2
	; -------------------
	; Launcher
	; -------------------
	:launcher
	
	int 0x2001 ;Dans tous les cas, on scrolle
	set A, pick 2
	set I, 0
	
	:launch_loop
		set B, [txt_commands + I]
		;On compare la commande (en A), et B (le pointeur vers la commande à tester)
		jsr strcmp
		
		;Si C'est bien cette commande, on lance le programe enregistré dans le tableau de pointeurs juste avant le tableau du nom des commandes : on doit donc soustraire le nombre de commandes.
		ife Z, 1
			set PC, console_launch
		
		add I, 1
		ifl I, [nb_commands]
			set PC, launch_loop
			
			
		
	; ----------------------
	; Commande non reconnue
	; ----------------------
	
	int INT_GETCOLOR
	set PUSH, B ;On sauvegarde la couleur actuelle de l'écran
	
	set B, 0x4000
	jsr change_couleur
	
	int 0x2001 ;Scroll
	
	set B, console_unknownCommand
	set I, SCREEN_HEIGHT
	set J, 1
	int 0x1000 ;Printf
	
	;Affichage de la commande ^^
	set J, 21
	set B, pick 3
	int 0x1000
	
	int 0x2001 ;Scroll
	
	set B, POP ;On récupère la couleur précédemment sauvegardée
	jsr change_couleur
	set PC, pop
	
:console_backspace
	ife J, 3
		set PC, console_readLine_loop
	set C,0x20
	int 0x1001
	sub J, 2 ;set [Z + J] ne marche pas, il y a trop de registres pour devCPU.
	add B, J ;Donc, on enlève les deux caractères de J en trop, on met l'adresse tampon à zéro, on remet Z normalement puis on rajoute 1 à J (ça évite de faire add J, 2 puis sub J, 1 ^^)
	set [B], 0
	sub B, J
	add J, 1

	set C, 0x220
	int 0x1001 ;On met un espace. Ca donnera 0x2020 en RAM mais ça n'a pas d'importance ^^
	set PC, console_readLine_loop
	
	
:console_launch
	set B, [ptr_commands + I]
	set push,console_endCommand
	set X,pick 3
	set Y,pick 4
	set I, SCREEN_HEIGHT
	set J, 1
	set PC, B
	
:console_endCommand
	int 0x2001
	set PC, pop
