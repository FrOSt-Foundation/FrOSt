; *************************
; Project: FrOSt
; File: input.dasm
; *************************

:console_readLine
	jsr push_regs
	
	set J, 3 ;Adresse du caractere sur la ligne
	set B, 31 ;On alloue 31 mots de memoire pour y enregistrer la commande (longueur de la ligne car on perd 2 cases avec l'invite ("> "), et un dernier mot = 0 pour que on puisse considerer ça comme une chaine :D
	int 0x0000 ;MALLOC
	ife Z, 0xFFFF ;Si on n'a plus de mémoire libre
		set PC, console_errorNotEnoughFreeSpace
		
	;Initialisation de la mémoire
	set B, Z
	int 0x0002
	
	set [Z + 30], 0 ;On met le dernier mot comme étant égal à 0, comme ça le tampon est une chaine.
	
	:console_readLine_loop
		int 0x4001 ;Attente que un caractère soit tapé. Celui-ci sera enregistré en C.
		ifn C, 0
			jsr console_processChar
		set PC, console_readLine_loop
		
	:console_readLine_end
	set B, Z
	int 0x0001 ;On libère la mémoire que l'on avait réservée.
	jsr pop_regs
	
	set PC, POP
	
	
:console_processChar
	ife C, 0x11 ;Return
		set PC, console_processCommand
	ife C, 0x10 ;Backspace
		set PC, console_backspace
	ife J, 32 ;Si on est a la fin de la ligne, on ne fait rien ^^
		set PC, POP
	;Si aucune des conditions ci-dessus n'est remplie, alors on affiche le caractere.
	;set I, SCREEN_HEIGHT ;On affichera le caractère à la dernière ligne.
	int 0x1001 ;printc
	
	sub J, 3 ;On enleve les deux caractères de J nécessaires à faire un affichage correct à l'écran
	
	;set [Z + J], C ne marche pas, il y a trop de registres pour DevCPU.
	add Z, J
	set [Z], C
	sub Z, J
	
	add J, 4 ;Puis on remet ces 2 caractères plus un autre puisque on vient de taper un caratère ^^
	 
	set PC, POP
	
	
:console_processCommand
	
	; ----------------------
	; Allocation de mémoire
	; ----------------------
	
	;Todo : Parser et lancer les différents programmes en fonction de la commande
	set PUSH, Z
	
	;On alloue de la mémoire pour y enregistrer la commande
	set B, 31
	int 0x0000 ;malloc
	ife Z, 0xFFFF
		set PC, console_errorNotEnoughFreeSpace
	set X, Z ;On enregistre la commande en X car on va faire un nouveau malloc ^^
	
	;Initialisation de la mémoire
	set B, X
	int 0x0002
	
	set B, 31
	int 0x0000 ;malloc
	ife Z, 0xFFFF
		set PC, console_errorNotEnoughFreeSpace
	set Y, Z ;On enregistre la commande en Y car on va poper Z : on a donc l'adresse de la commande entière en Z, de la future commande parsée en X et des futurs arguments en Y.
	
	;Initialisation de la mémoire
	set B, Y
	int 0x0002
	
	; --------------
	; Parser
	; --------------
	
	;On peek Z. Pas besoin pour X et Y car ils sont déjà sauvegardés.
	set Z, PEEK
	
	;Sauvegarde de la position initiale de X et de Y
	set PUSH, Y
	set PUSH, X
	
	;On met la fin de chaque bloc mémoire alloué à zéro pour en faire une chaine de caractères valide.
	set [X + 30], 0
	set [Y + 30], 0
	:console_processCommand_loop
		ifl [Z], 0x21 ;Si on tombe sur l'espace ou \t ou \n ou \0, on quitte la boucle
			set PC, console_processCommand_endLoop
		set [X], [Z]
		add X, 1
		add Z, 1
		set PC, console_processCommand_loop
	
	:console_processCommand_endLoop
	add Z, 1
	
	;On copie les arguments en Y maintenant
	:console_processCommand_loop2
		ife [Z], 0x0 ;On ne veut s'arrêter QUE si on est à la fin, on prend tous les arguments en une seule chaine.
			set PC, console_processCommand_endLoop2
		set [Y], [Z]
		add Y, 1
		add Z, 1
		set PC, console_processCommand_loop2
	
	:console_processCommand_endLoop2
	
	;On restaure X, Y et Z.
	set X, POP
	set Y, POP
	set Z, POP
	
	; -------------------
	; Launcher
	; -------------------
	
	set PUSH, Z ;On sauvegarde Z car il est modifié par strcmp
	
	set A, txt_commands
	sub A, ptr_commands
	set [nb_commands], A
	
	int 0x2000 ;Dans tous les cas, on scrolle
	set A, X
	set B, txt_commands
	:launch_loop
		;On compare la commande (A), et B (le pointeur vers la commande à tester)
		jsr strcmp
		
		;Si C'est bien cette commande, on lance le programe enregistré dans le tableau de pointeurs juste avant le tableau du nom des commandes : on doit donc soustraire le nombre de commandes.
		ife Z, 1
			sub B, [nb_commands]
		ife Z, 1
			set PUSH, console_endCommand
		ife Z, 1
			set PC, [B]
		
		add B, 1
		ifl B, txt_commands_end
			set PC, launch_loop
			
			
		
	; ----------------------
	; Commande non reconnue
	; ----------------------
	
	set Z, POP ;On reprend Z sauvegardé avec le launcher
	
	;On libère Y, Z sera libéré plus tard et on a besoin de X juste après
	set B, Y
	int 0x0001 ;Free
	
	set B, 0x4000
	jsr change_couleur
	
	int 0x2001 ;Scroll
	
	set B, console_unknownCommand
	set I, SCREEN_HEIGHT
	set J, 1
	int 0x1000 ;Printf
	
	;Affichage de la commande ^^
	set J, 21
	set B, X
	int 0x1000
	
	;On n'a plus besoin de X, on le libère
	set B, X
	int 0x0001 ;Free
	
	int 0x2001 ;Scroll
	
	set B, 0x2000
	jsr change_couleur
	
	set J, POP
	set PC, console_readLine_end
	
:console_backspace
	ife J, 3 ;Si on est au début de la ligne, on ne fait rien ^^
		set B, POP
	ife J, 3
		set PC, console_readLine_loop
	
	sub J, 2 ;set [Z + J] ne marche pas, il y a trop de registres pour devCPU.
	add Z, J ;Donc, on enlève les deux caractères de J en trop, on met l'adresse tampon à zéro, on remet Z normalement puis on rajoute 1 à J (ça évite de faire add J, 2 puis sub J, 1 ^^)
	set [Z], 0
	sub Z, J
	add J, 1

	set C, 0x20
	int 0x1001 ;On met un espace. Ca donnera 0x2020 en RAM mais ça n'a pas d'importance ^^
	
	set PC, POP
	
:console_endCommand
	set Z, POP ;On reprend Z sauvegardé avec le launcher
	set B, X
	int 0x0001 ;Free
	set B, Y
	int 0x0001 ;Free
	
	set J, POP
	set PC, console_readLine_end