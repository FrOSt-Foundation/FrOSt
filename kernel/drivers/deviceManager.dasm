:deviceManager_init
    jsr push_regs

    hwn I
    set J, 0
    :loop_periph
        hwq J
        set X, 0xFFFF

        ife A, CLOCK_ID_A
            ife B, CLOCK_ID_B
                set X, DEVICE_CLOCK

        ife A, EDC_ID_A
            ife B, EDC_ID_B
                set X, DEVICE_EDC

        ife A, FDD_ID_A
            ife B, FDD_ID_B
                set X, DEVICE_DD

        ife A, HDD_ID_A
            ife B, HDD_ID_B
                set X, DEVICE_DD
        ife A, HDD_ID_A
            ife B, HDD_ID_B
                jsr __deviceManager_spin_up_HDD

        ife A, IACM_ID_A
            ife B, IACM_ID_B
                set X, DEVICE_IACM

        ife A, KEYBOARD_ID_A
            ife B, KEYBOARD_ID_B
                set X, DEVICE_KEYBOARD

        ife A, LEM802_ID_A
            ife B, LEM1800_ID_B
                set X, DEVICE_SCREEN

        jsr deviceManager_addDevice

        add J, 1

        ife X, 0xFFFF
            ifn I, J
                set PC, loop_periph ; The device is unknown, we ignore it.
        ifn I, J
            set PC, loop_periph

    jsr pop_regs
    set PC, POP

:__deviceManager_spin_up_HDD
    set PUSH, A
        set A, 0x0004
        hwi J
    set A, POP

    set PC, POP

; Arguments : J id, X DEVICE_*

:deviceManager_addDevice
    set PUSH, C

    set A, deviceManager_numbers
    add A, X

    ife [A], 0
        jsr deviceManager_addDevice_malloc
    ifn [A], 0
        jsr deviceManager_addDevice_getalloc

    add Z, [A]
    set [Z], J

    add [A], 1

    set A, deviceManager_drivers_dataSizes_pointer
    add A, X
    set PUSH, [A]
    ifn [A], 0
        jsr deviceManager_addDevice_mallocData
    set [A], POP

    ; Let's run the driver initialization method. J is the device ID, Y is the device version, and Z a pointer to the device data (if needed). These are the only arguments the driver should consider as reliable
    set Y, POP
    set A, deviceManager_drivers_pointers
    add A, X
    jsr push_regs
    jsr [A]
    jsr pop_regs

    set PC, POP

    :deviceManager_addDevice_malloc
        set B, MAX_DEVICES_PER_DRIVER
        int INT_MALLOC
        ife Z, MALLOC_ERROR
            set PC, end

        set B, deviceManager_pointers
        add B, X
        set [B], Z

        set PC, POP

    :deviceManager_addDevice_getalloc
        set B, deviceManager_pointers
        add B, X
        set Z, [B]

        set PC, POP

    :deviceManager_addDevice_mallocData
        set PUSH, C

        set C, deviceManager_numbers
        add C, X
        set B, [A]
        mul B, [C]
        ife [C], 1 ; If this is the first device of this type ever detected
            set PC, deviceManager_addDevice_mallocData_malloc
        set PC, deviceManager_addDevice_mallocData_realloc

        :deviceManager_addDevice_mallocData_malloc
            int INT_MALLOC
            ife Z, MALLOC_ERROR
                set PC, end

            set C, B
            set B, deviceManager_drivers_data_pointers
            add B, X
            set [B], Z

            set C, POP
            set PC, POP
        :deviceManager_addDevice_mallocData_realloc
            set C, B
            set B, deviceManager_drivers_data_pointers
            add B, X
            set B, [B]

            int INT_REALLOC
            ife A, MALLOC_ERROR
                set PC, end

            ; We seed Z to this specific device's data location
            set Z, A
            set C, X
            mul C, PEEK
            add Z, C

            set C, POP
            set PC, POP


;
; A POINTS TO THE USER STACK.
; Must be pushed to the stack, in order:
; - Arguments
; - SP
; - Device ID
; - Function
; - Device type
;

:deviceManager_interrupt
    set PUSH, A

    set PUSH, X
        set X, [A] ; X is now the device type
        set J, [A + 2] ; J is now the device ID
        mul J, [deviceManager_drivers_dataSizes_pointer + X] ; -> J is now (device ID * device size)
        set Z, [deviceManager_drivers_data_pointers + X] ; -> Z is now a pointer to the drive data block
        add Z, J ; -> Z is now a pointer to the _device_ data block

        set J, [deviceManager_pointers + X]
        add J, [A + 2]
        set J, [J]

    set X, POP

    ife [A], DEVICE_CLOCK
        set PC, deviceManager_interrupt_clock
    ife [A], DEVICE_EDC
        set PC, deviceManager_interrupt_edc
    ife [A], DEVICE_DD
        set PC, deviceManager_interrupt_dd
    ife [A], DEVICE_IACM
        set PC, deviceManager_interrupt_iacm
    ife [A], DEVICE_KEYBOARD
        set PC, deviceManager_interrupt_keyboard
    ife [A], DEVICE_SCREEN
        set PC, deviceManager_interrupt_screen

    :deviceManager_interrupt_resume

    set A, POP

    set SP, A ; SP is now how it was when the user called INT

    set A, POP ; Don't forget A was pushed on the stack when INT was called

    ; Current state of the stack is:
    ; [...] (MSB)
    ; <Device ID>
    ; <Function>
    ; <Device type>
    ; <PC>
    ; [...] (LSB)
    set 0, POP
    set 0, POP
    set 0, POP

    iaq 1

    brk 0

    set PC, [SP + 0xFFFB] ; No RFI in this case, we did it manually by handling the stack

    :deviceManager_interrupt_clock
        ; Ok, this part is sketchy
        ; We want the driver to have a stack pointer in A that points to the arguments provided by the user. That means we have to add 4 to A.
        ; However, we also have to use [A + 1] to compare to the functions of the driver.
        ; We don't want to set a register now, because it's naughty to temper with them (although in an ideal world drivers should only need A, J and Z).
        ; So we store the function we want to go to in the stack
        ; And we have to push it and THEN access it via [SP], because if the function doesn't exist (none if the IFE's are executed), we still want to go somewhere.

        set PUSH, deviceManager_interrupt_resume
        set PUSH, deviceManager_interrupt_resume

        ife [A + 1], CLOCK_GETTIME
            set [SP], clock_getTime
        ife [A + 1], CLOCK_RESETTIME
            set [SP], clock_resetTime
        ife [A + 1], CLOCK_GETSPEED
            set [SP], clock_getSpeed
        ife [A + 1], CLOCK_SETSPEED
            set [SP], clock_setSpeed
        ife [A + 1], CLOCK_GETINTERRUPT
            set [SP], clock_getInterrupt
        ife [A + 1], CLOCK_SETINTERRUPT
            set [SP], clock_setInterrupt

        add A, 4 ; We change the stack pointer for the driver.

        set PC, POP ; We go to the desired function. On set PC, POP, it will go to deviceManager_interrupt_resume since we pushed it twice! #sketchy

    :deviceManager_interrupt_edc

        set PC, POP

    :deviceManager_interrupt_dd

        set PC, POP

    :deviceManager_interrupt_iacm

        set PC, POP

    :deviceManager_interrupt_keyboard

        set PC, POP

    :deviceManager_interrupt_screen

        set PC, POP
