;struct process : int id, int priority, char* name, int* SP,  int* screen -> 5 words
;the pc register is saved on the stack, then A,B,C,X,Y,Z,I,J,Ex in this order
;if screen=0, then there is no need for a screen so the program is never displayed
;priority : 1-10 automatic

;max 4 process at a time

:key_need dat 0,0,0,0
:disk_need dat 0,0,0,0
:clock_need dat 0,0,0,0
:process dat 0,0,0,0
:counter dat 0
:running_process dat 0 ;how many are running currently
:current_process dat 0 ;the index in the process tab
:screen_process dat 0 ;the process with the screen printed
:total_prio dat 0

;-----------------------------------
;add a proc, adress in A, name in B
;if a screen is needed, then C is 1 otherwise it is 0
;if there's a screen, the screen changes
;-----------------------------------
:Sched_AddProc
ife [running_process],4
	set pc,end
add [running_process],1
set push,Z
set push,[currently_running]
set push,A
set A,5
jsr malloc
ife Z,0xFFFF
	set pc,end
set A,process
sub A,1
:Sched_AddProc_loop1
add A,1
ifn [A],0
	ifn A,counter
		set pc,Sched_AddProc_loop1
ife A,counter
	set pc,Sched_AddProc_error
set [A],Z
set A,Z
set [A],[counter]
add [counter],1
set [currently_running],A
set [A+1],10 ;max prio pour lui passer la main
add [total_prio],10
set [A+2],B
set push,A
set A,0x30
jsr malloc
ife Z,0xFFFF
	set pc,end
set A,peek
set [Z+0x2F],[SP+1]
add Z,0x26
set [A+3],Z
ife C,0
	set pc,Sched_AddProc_noScreen
set A,[ecran_taille]
jsr malloc
ife Z,0xFFFF
	set pc,end
set push,B
set B,Z
jsr set_vram
set B,pop
set A,pop
set [A+4],Z
set A,pop
set A,[currently_running]
set [currently_running],pop
set [screen_process],A
set Z,pop
set pc,Sched_changer

:Sched_AddProc_error
set A,Z
jsr free
set A,pop
set Z,pop
set Z,pop
set pc,pop

:Sched_AddProc_noScreen
set [A+4],0
set A,pop
set A,pop
set A,[currently_running]
set [currently_running],pop
set Z,pop
set pc,Sched_changer

;----------------------------------------
;changes the program currently running to the one in A
;assumes the current stack has already pc then A
;if A==0 then it's the OS that's running.
;reset the clock
;/!\ does a rfi 0 to return to the program /!\
;you have to jump to this routine directly
;----------------------------------------
:Sched_changer
;saving the current process
set push,B
set push,C
set push,X
set push,Y
set push,Z
set push,I
set push,J
set push,Ex
set B,A
set A,[currently_running]
ifn A,0
	set [A+3],SP
ife A,0
	set [KER_SP],SP
ifn B,0
	set SP,[B+3]
ife B,0
	set SP,[KER_SP]
set [currently_running],B
;set the clock to tick once the time to the current program is elapsed
ifn B,0
	set B,[B+1]
set A,[total_prio]
add A,1
div B,A
set B,Ex
mul B,60
set B,Ex
ife B,0
	ifn 0,[currently_running]
		set B,62
set A,0
hwi [id_clock]
;restore the program
set Ex,pop
set J,pop
set I,pop
set Z,pop
set Y,pop
set X,pop
set C,pop
set B,pop
rfi 0

;----------------------------------
;freezes the current program until the keyboard triggers an int
;----------------------------------
:Sched_keyBlock
set push,B
set A,SP
set SP,key_need
:Sched_keyBlock_loop1
ifn 0,pop
	set pc,Sched_keyBlock_loop1
set B,SP
set SP,A
sub B,1
set [B],[currently_running]
set B,[B]
sub [total_prio],[B+1]
set A,process
add A,[current_process]
set [A],0
add A,1
ife A,counter
	set A,process
set [current_process],A
sub [current_process],process
set A,[A]
set B,pop
set pc,Sched_changer

;------------------------------------
;resumes the program with the screen waiting for a key
;------------------------------------
:Sched_key
set A,key_need
sub A,1
:Sched_key_loop1
add A,1
ifn [A],[screen_process]
	ifn A,disk_need
		set pc,Sched_key_loop1
ife A,disk_need ;il n'est pas dans la liste d'attente, on retourne
	rfi 0
set push,B
set push,[A]
set [A],0
set B,SP
set SP,process
:Sched_key_loop2
ifn 0,pop
	set pc,Sched_key_loop2
set A,SP
sub A,1
set SP,B
set [A],pop
set [current_process],A
sub [current_process],process
set A,[A]
add [total_prio],[A+1]
set push,C
set push,A
set A,1
hwi [id_clavier]
set A,peek
set A,[A+3]
set [A+6],C
set A,pop
set C,pop
set B,pop
set pc,Sched_changer

;------------------------------------
;kill a program which ID is in A (it's the same as terminate, but much shorter to write :p )
;------------------------------------
:Sched_kill
