;struct program : 
;int PID
;char* screen (if==0 then no screen)
;int time (time elapsed since it's been running)
;char* SP (save for SP)
;char *KER_SP (save for kernel SP)
;int CPUtime (time he has to run)
;char* name
;int PIDParent (the parent who created the process)

;processes treated in a "round-robin" modified way :
;the process who is on screen gets more time and more often
;than others (not yet, it's still a caroussel :p )

;the clock should tick 20 times per second (so once every 3ms)
;if the interrupt doesn't use more than 40 cycles
;then the program gets 125 cycles per second (assuming all
;4 processes running together).

:process_readyToRun dat 0,0,0,0
:process_waitingKBD dat 0,0,0,0
:process_waitingHDD dat 0,0,0,0

:nbprocess dat 0

:KER_PROCESS dat 0,0,0,0,0,1,0,0

;Adress of the program in A
;Assuming the program is already copied in RAM
;Adress of the name in B
;if C==1 then Screen, otherwise no screen

:Sched_addProc
set push,B
set push,A
set push,[currently_running]
set [currently_running],0
set A,8
jsr malloc
ife Z,0xFFFF
	set pc,end ;error
set [currently_running],pop
add [nbprocess],1
set [Z],[nbprocess] ;pid
set [Z+2],1 ;time
set [Z+5],1 ;cpu time
set [Z+6],B ;name
set [Z+7],[currently_running] ;parent pid
set push,Z
set Z,0
set A,SCREEN_SIZE
ife C,1
	jsr malloc
ife Z,0xFFFF
	set pc,end
set B,pop
set [B+1],Z ;screen
set A,0x3F
jsr malloc
ife Z,0xFFFF
	set pc,end
add A,0xF
set [B+4],A ;ker_sp
add A,0x26
set [B+3],A ;sp
add A,9
set [A],pop
;adding to the processes list
set A,process_readyToRun
sub A,1
:Sched_addProc_loop
add A,1
ifn A,process_waitingKBD
	ifn A,0
		set pc,Sched_addProc_loop
ife A,process_waitingKBD
	set pc,end
set [A],B
set B,pop
set pc,Sched_change


;change current running process with the next one
:Sched_change
;saving current context
set push,B
set push,C
set push,X
set push,Y
set push,Z
set push,I
set push,J
set push,Ex
;choosing the next process
set A,process_readyToRun
set B,[currently_running]
sub A,1
:Sched_change_loop1
add A,1
ifn A,process_waitingKBD
	ifn A,B
		set pc,Sched_change_loop1
ife A,process_waitingKBD
	set A,process_readyToRun
add A,1
ife A,process_waitingKBD
	set A,process_readyToRun
ife B,0
	set B,KER_PROCESS
set [B+3],SP
ife A,0
	set A,KER_PROCESS
set SP,[A+3]
set [currently_running],A
;updating time
set [A+2],[A+5]
;restoring context
set Ex,pop
set J,pop
set I,pop
set Z,pop
set Y,pop
set X,pop
set C,pop
set B,pop
rfi 0
