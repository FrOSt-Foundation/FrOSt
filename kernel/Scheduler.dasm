;Struct process : ID,char* nom,SP,*screen,prio
;4 process en meme temps
;3 files differentes : une normale, une pour le clavier, une pour l'acess diquette
;prio : 1-10, 10 le plus prioritaire, automatique

:nb_procs dat 1 ;augmente a chaque nouveau programme, OS compte pour 1 (ID)

:procs dat 0,0,0,0 ;le tableau de structures procs. Liste des programmes en execution normale
:key_procs dat 0,0,0,0 ;le tableau de structs procs en attente d'une touche.

:proc_run dat 0 ;addresse de la structure proc du programme courant. Si proc_run==0, alors pas de programme lance

;adresse du programme charge en memoire et le MMU est passe en A.
;SP est deja bien positionne
;Adresse du nom en B
;args en C,X,Y,I,J,Z
;met une prio de 3
:Sched_AddProc
ifn [procs+3],0
	set pc,end
iaq 1
set push,A
set push,Z
set A,4
jsr malloc
ife Z,0xFFFF
	set pc,end
set [Z],[nb_procs]
add [nb_procs],1
set [Z+1],B
set push,Z
set A,384
jsr malloc
ife Z,0xFFFF
	set pc,end
set A,Z
set Z,pop
set [Z+3],A
set A,procs
sub A,1
.Sched_add_boucle
add A,1
ifn A,key_procs
	ifn [A],0
		set pc,Sched_add_boucle
ife A,key_procs
	set pc,Sched_add_end
set [A],Z
set [proc_run],Z
set A,[proc_run]
set [Z+4],3
jsr SetProcScreen
set Z,pop
set A,pop
set [currently_running],[proc_run]
jsr sched_clock
iaq 0
ife set pc,A
:Sched_add_end
set B,pop
set Z,pop
set A,pop
set pc,end

:Scheduler ;on verifie quel type d'int l'a appele
set push,C
set A,1
hwi [id_clavier]
ife C,0x12
	set pc,TurnScreen
set [tmpSched],C
set C,pop
ife [key_int],1
	ifn [key_procs],0
		set pc,Sched_key
.Sched_fin
set [key_int],0
set A,0
hwi [id_clavier]
rfi 0

:Sched_key ;le clavier a declenche un int, on verifie si le programme a l ecran a demande
set A,key_procs
sub A,1
.keyS_boucle1
add A,1
ifn A,proc_run
	ifn [A],[proc_ecran]
		set pc,keyS_boucle1
ife A,proc_run
	set pc,Sched_fin
jsr push_regs
set B,procs
sub B,1
.keyS_boucle2
add B,1
ifn B,key_procs
	ifn [B],0
		set pc,keyS_boucle2
set [B],[A]
set [A],0
ife [currently_running],0
	set pc,Sched_keyS
;on sav le programme en cours
set A,[proc_run]
set [A+2],SP
.Sched_keyS_next
set [proc_run],[B]
set A,[proc_run]
set SP,[A+2]
set [currently_running],[A]
jsr pop_regs
set C,[tmpSched]
rfi 0
.Sched_keyS
set [KER_SP],SP
set pc,Sched_keyS_next

:Sched_keyBlock
;On deplace le programme dans la liste speciale. On passe ensuite a un autre programme, sinon a la boucle d'attente.
;on sav tout
jsr push_regs
set A,[proc_run]
set [A+2],SP
set SP,key_procs
.keyB_boucle1
ifn 0,pop
	set pc,keyB_boucle1
set A,SP
sub A,1
set [A],[proc_run] ;programme sav
set SP,procs
.keyB_boucle2
ifn [proc_run],pop
	set pc,keyB_boucle2
set A,SP
sub A,1
set [A],0 ;on l'enleve des programmes en cours
;on passe au suivant
set A,procs
sub A,1
.keyB_boucle3
add A,1
ifn A,key_procs
	ife [A],0
		set pc,keyB_boucle3
ife A,key_procs
	set pc,Sched_keyB
ife [A],0
	set pc,Sched_keyB
set [proc_run],[A]
set A,[proc_run]
set SP,[A+2]
jsr SetProcScreen
set [currently_running],[A]
jsr pop_regs
rfi 0
.Sched_keyB
set [currently_running],0
set SP,[KER_SP]
iaq 0
set pc,attente

;----------------------------------
;change l horloge
;----------------------------------
:sched_clock
