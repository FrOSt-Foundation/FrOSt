;Struct process : ID,char* nom,SP,*screen
;4 process en meme temps
;4 files differentes : une normale, une pour le clavier, une pour le "sleep" X tick, une pour l'acess diquette

:nb_procs dat 1 ;augmente a chaque nouveau programme, OS compte pour 1 (ID)

:procs dat 0,0,0,0 ;le tableau de structures procs. Liste des programmes en execution normale
:key_procs dat 0,0,0,0 ;le tableau de structs procs en attente d'une touche.

:proc_run dat 0 ;addresse de la structure proc du programme courant. Si proc_run==0, alors pas de programme lance

;adresse du programme charge en memoire et le MMU est passe en A.
;SP est deja bien positionne
;Adresse du nom en B
;args en C,X,Y,I,J,Z
:Sched_AddProc
ifn [procs+3],0
	set pc,end
iaq 1
set push,A
set push,Z
set A,4
jsr malloc
ife Z,0xFFFF
	set pc,end
set [Z],[nb_procs]
add [nb_procs],1
set [Z+1],B
set push,Z
set A,384
jsr malloc
ife Z,0xFFFF
	set pc,end
set A,Z
set Z,pop
set [Z+3],A
set A,procs
sub A,1
set push,B
set B,procs
add B,4
.Sched_add_boucle
add A,1
ifn A,B
	ifn [A],0
		set pc,Sched_add_boucle
ife A,B
	set pc,Sched_add_end
set [A],Z
set [proc_run],Z
set B,[Z+3]
jsr set_vram
set B,pop
set Z,pop
set A,pop
set [currently_running],[proc_run]
iaq 0
set pc,A
:Sched_add_end
set B,pop
set Z,pop
set A,pop
set pc,end

:Scheduler ;on verifie quel type d'int l'a appele
ife [key_int],1
	ifn [key_procs],0
		set pc,Sched_key
set [key_int],0
set A,0
hwi [id_clavier]
rfi 0

:Sched_key ;le clavier a declenche un int, on rend la main a tous les programmes en attente
jsr push_regs
set [key_int],0
set A,key_procs
sub A,1
set B,procs
sub B,1
set C,0
.keyS_boucle1
.keyS_boucle2
add A,1
ifn A,proc_run
	ife [A],0
		set pc,keyS_boucle2
.keyS_boucle3
add B,1
ifn B,key_procs
	ifn [B],0
		set pc,keyS_boucle3
ife A,proc_run
	set pc,keyS_Fboucle1
ife B,key_procs
	set pc,keyS_Fboucle1
ife C,0
	set C,B
set [B],[A]
set [A],0
set pc,keyS_boucle1
.keyS_Fboucle1
ife [currently_running],0
	set pc,Sched_keyS
;on sav le programme en cours
set A,[proc_run]
set [A+2],SP
.Sched_keyS_next
set [proc_run],[C]
set A,[proc_run]
set SP,[A+2]
set [currently_running],[A]
jsr pop_regs
set A,1
hwi [id_clavier]
rfi 0
.Sched_keyS
set [KER_SP],SP
set pc,Sched_keyS_next

:Sched_keyBlock
;On deplace le programme dans la liste speciale. On passe ensuite a un autre programme, sinon a la boucle d'attente.
;on sav tout
jsr push_regs
set A,[proc_run]
set [A+2],SP
set SP,key_procs
.keyB_boucle1
ifn 0,pop
	set pc,keyB_boucle1
set A,SP
sub A,1
set [A],[proc_run] ;programme sav
set SP,procs
.keyB_boucle2
ifn [proc_run],pop
	set pc,keyB_boucle2
set A,SP
sub A,1
set [A],0 ;on l'enleve des programmes en cours
;on passe au suivant
set A,procs
sub A,1
.keyB_boucle3
add A,1
ifn A,key_procs
	ife [A],0
		set pc,keyB_boucle3
ife A,key_procs
	set pc,Sched_keyB
ife [A],0
	set pc,Sched_keyB
set [proc_run],[A]
set A,[proc_run]
set SP,[A+2]
set B,[A+3]
jsr set_vram
set [currently_running],[A]
jsr pop_regs
rfi 0
.Sched_keyB
set [currently_running],0
set SP,[KER_SP]
iaq 0
set pc,attente