;struct process : int id, int priority, char* name, int* SP,  int* screen -> 5 words
;the pc register is saved on the stack, then A,B,C,X,Y,Z,I,J,Ex in this order
;if screen=0, then there is no need for a screen so the program is never displayed
;priority : 1-10 automatic

;max 8 process at a time

:process dat 0,0,0,0,0,0,0,0
:counter dat 0
:running_process dat 0 ;how many are running currently
:total_prio dat 0

;-----------------------------------
;add a proc, adress in A, name in B
;if a screen is needed, then C is 1 otherwise it is 0
;-----------------------------------
:Sched_AddProc
ife [running_process],8
	set pc,end
add [running_process],1
set push,Z
set push,[currently_running]
set push,A
set A,5
jsr malloc
ife Z,0xFFFF
	set pc,end
set A,process
sub A,1
.loop1
add A,1
ifn [A],0
	ifn A,counter
		set pc,loop1
ife A,counter
	set pc,Sched_AddProc_error
set [A],Z
set A,Z
set [A],[counter]
add [counter],1
set [currently_running],A
set [A+1],10 ;max prio pour lui passer la main
add [total_prio],10
set [A+2],B
set push,A
set A,0x30
jsr malloc
ife Z,0xFFFF
	set pc,end
set A,peek
set [Z+0x2F],[SP+1]
add Z,0x26
set [A+3],Z
set A,[ecran_taille]
ife C,0
	set pc,Sched_AddProc_noScreen
jsr malloc
ife Z,0xFFFF
	set pc,end
set push,B
set B,Z
jsr set_vram
set B,pop
set A,pop
set [A+4],Z
set A,pop
set [currently_running],pop
set Z,pop
set pc,Sched_changer

.Sched_AddProc_error
set A,Z
jsr free
set A,pop
set Z,pop
set Z,pop
set pc,pop

.Sched_AddProc_noScreen
set A,pop
set A,pop
set [currently_running],pop
set Z,pop
set pc,Sched_changer

;----------------------------------------
;change the program currently running to the next one (NO PRIORITY FOR NOW)
;assume the current stack has already pc then A
;reset the clock
;/!\ does a rfi 0 to return to the program /!\
;you have to jump to this routine directly
;----------------------------------------
:Sched_changer
set A,process
sub A,1
;looking for the current process in the list
.loop1
add A,1
ifn A,counter
	ifn [A],[currently_running]
		set pc,loop1
ife A,counter
	set pc,Sched_Changer_error
;looking for the next process to execute
.loop2
add A,1
ife A,counter
	set A,process
ife [A],0
	set pc,loop2
;saving the current process
set push,B
set push,C
set push,X
set push,Y
set push,Z
set push,I
set push,J
set push,Ex
set B,[A]
set A,[currently_running]
ifn A,0
	set [A+3],SP
ife A,0
	set [KER_SP],SP
set SP,[B+3]
set [currently_running],B
;set the clock to tick once the time to the current program is elapsed
set B,[B+1]
set A,[total_prio]
sub A,1
div B,A
set B,Ex
mul B,60
ife B,0
	set B,60
set A,0
hwi [id_clock]
;restore the program
set Ex,pop
set J,pop
set I,pop
set Z,pop
set Y,pop
set X,pop
set C,pop
set B,pop
rfi 0

.Sched_changer_error
set pc,end