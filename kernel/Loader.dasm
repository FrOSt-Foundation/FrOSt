;---------------------------------------------
;LOADER loads a program at adress A from hw B
;args are in C,X,Y,Z,I,J
;a new stack is prepared
;call this with jsr
;---------------------------------------------
:Loader
;recuperer la taille du programme dans C
;pour la pile
add C,0x200
set push,A
jsr malloc
ife B,0xFFF
	set PC,Loader_end
set A,pop
;copier le programme en [B]
set A,B
add A,1
set push,B
set B,0
set C,peek
jsr MMU
;on a deplace les offsets
set B,pop
jsr push_regs
set [KER_SP],SP
sub A,2
set SP,[A]
add A,2
;on enregistre le programme dans le sched
set B,[Sched_table_prog]
sub B,1
add B,1
ifn [B],0
	sub PC,3
set [B],A
sub B,Sched_table_prog
set [Sched_current],B
add B,Sched_table_prio
;on met le mot de prio
set [B],[A]
add A,1
add [Sched_number],1
;IL faut modifier les dats présents en fonction des priorités.
;on passe la main au prog
set PC,A
:Loader_end
set Z,pop
set A,pop
set PC,pop


;---------------------------------------------
;FINISHER finish a program properly
;call with jsr
;return to the console
;---------------------------------------------
:Finisher
;boucle pour savoir dans quel bloc on est
;A contient ancienne adr de PC
set A,pop
set B,[start_mem]
:Finisher_loop
set C,B
add C,[C+1]
ifg A,B
	ifl A,C
		set PC,Finisher_next
set B,[B+2]
set PC,Finisher_loop
:Finisher_next
;on a en B le bloc
set A,B
jsr free
set A,Sched_table_prog
set X,Sched_table_prio
set I,Sched_table_sp
set Z,[Sched_current]
add A,Z
add X,Z
add I,Z
:Finisher_modif
add Z,1
ife Z,15
	set PC,Finisher_next_next
set B,A
set Y,X
set J,I
add A,1
add X,1
add I,1
set [B],[A]
set [Y],[X]
set [J],[I]
set PC,Finisher_modif
set [A],0
set [X],0
set [I],0
:Finisher_next_next
set SP,[KER_SP]
jsr pop_regs
sub [Sched_number],1
set PC,pop
