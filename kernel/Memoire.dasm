;memoire
;schema d'un bloc de memoire : proprio|taille|data si proprio=0xFFFF->bloc libre

;malloc
;A contient la taille, retour de l'adresse dans Z si B=0xFFFF alors erreur
:malloc
	set Z,0xFFFF
	set push,A
	add A,2
	ifg A,[free_mem]
		set pc,malloc_error
	ifl A,2 ;si la taille est inferieure ou egale a 0
		set pc,malloc_error
	ife A,2
		set pc,malloc_error
	sub [free_mem],A
	;on parcours la mÃ©moire pour savoir s'il y a un bloc assez grand
	set push,I
	set I,[start_mem]
	:malloc_boucle
		ife [I],0xFFFF
			set pc,malloc_bloc_libre	
	:malloc_continue
		add I,[I+1]
		ifn I,[end_mem]
			set pc,malloc_boucle
	:malloc_error
		set I,pop
		set A,pop
		set pc,pop
		;un bloc est libre, verification de la taille
	:malloc_bloc_libre
		ifg [I+1],A
				set pc,malloc_new_bloc
		ife [I+1],A
				set pc,malloc_return
		set pc,malloc_continue
	;on a une taille trop grande
	;on decoupe
	:malloc_new_bloc
		set push,[I+1]
		set [I+1],A
		add I,A
		set [I],0xFFFF
		sub peek,A
		set [I+1],pop
		sub I,A
	;on retourne le pointeur apres avoir update l'header
	:malloc_return
		set Z,I
		set [Z],[currently_running]
		add Z,2
		set I,pop
		set A,pop
		set pc,pop

;adresse dans A
:free
	;on trouve le bon bloc memoire, au cas ou
	set push,B
	set push,A
	set A,[start_mem]
	set B,[start_mem]
	:free_boucle
		ifg B,peek
			set pc,free_found
		set A,B
		add B,[B+1]
		set pc,free_boucle
		;bloc memoire a free trouve, on libere
	:free_found
		set [A],0xFFFF
		add [free_mem],[A+1]
		;recollage a droite
		ifn [B],0xFFFF
			set pc,free_gauche
		add A,1
		add [A],[B+1]
		sub A,1
		;recollage a gauche
	:free_gauche
		set B,[start_mem]
		set push,C
		set C,[start_mem]
		;on recupere l'adresse du bloc a gauche
		:free_gauche_boucle
			add C,[C+1]
			ife A,C
				set pc,free_gauche_end
			add B,[B+1]
			set pc,free_gauche_boucle
			;on concatene si besoin est
		:free_gauche_end
			ifn [B],0xFFFF
				set pc,free_end
			add B,1
			add [B],[A+1]
	:free_end
		set C,pop
		set A,pop
		set B,pop
		set pc,pop

;libere toute la memoire allouee par un programme, ID du programme dans A
:free_program
	set push,A
	set A,[start_mem]
	:boucle_recherche
		ife [A],peek
			jsr free
		add A,[A+1]
		ifn A,[end_mem]
			set pc,boucle_recherche
		set A,pop
		set pc,pop

;met 0 dans la memoire allouee en A /!\ il faut que la memoire soit allouee !
:efface_memoire
	;on trouve le bon bloc memoire
	set push,B
	set push,A
	set A,[start_mem]
	set B,[start_mem]
	:eff_boucle
		ifg B,peek
			set pc,eff_found
		set A,B
		add B,[B+1]
		set pc,eff_boucle
		;bloc memoire a effacer trouve, on efface
	:eff_found
		set B,SP
		set SP,A
		add SP,[A+1]
		add A,2
	:eff_eff
		set push,0
		ifn A,SP
			set pc,eff_eff
		;bloc entierement vide
		set SP,B
		set A,pop
		set B,pop
		set pc,pop

;--------------------------------------
;memcpy copy de [B] vers [A] C mots
;--------------------------------------
:memcpy
	set push,I
	set push,J
	set push,C
	set push,C
	set I,A
	set J,B
	add C,B
	ifl peek,8
		set pc,memcpy_boucle2
	mod peek,8
	ifn peek,0
		set pc,memcpy_boucle3
	:memcpy_boucle
		sti [I],[J]
		sti [I],[J]
		sti [I],[J]
		sti [I],[J]
		sti [I],[J]
		sti [I],[J]
		sti [I],[J]
		sti [I],[J]
		ifn C,J
			set pc, memcpy_boucle
		set C,pop
		set C,pop
		set J,pop
		set I,pop
		set pc,pop
	:memcpy_boucle2
		sti [I],[J]
		ifn C,J
			set pc,memcpy_boucle
		set C,pop
		set C,pop
		set C,pop
		set C,pop
		set J,pop
		set I,pop
		
		set pc,pop

	:memcpy_boucle3
		sti [I],[J]
		sub peek,1
		ifn peek,0
			set pc,memcpy_boucle3
		set pc,memcpy_boucle

;--------------------------------------
;size renvoie la taille dans B de l'adresse A
;--------------------------------------
:size
	;on trouve le bon bloc memoire
	set push,A
	set A,[start_mem]
	set B,[start_mem]
	:size_boucle
		ifg B,peek
			set pc,size_found
		set A,B
		add B,[B+1]
		set pc,size_boucle
	;bloc memoire trouve, on efface
	:size_found
		set B,[A+1]
		sub B,2
		set A,pop
		set pc,pop

;--------------------------------------
;Realloc, realloue l'adresse A avec la taille B, et copie les donnees de A vers B (tronque si A>B)
;si l'adresse suivante est libre, on empiete
;A contient la nouvelle adresse, 0xFFFF si erreur
;--------------------------------------
:realloc
	set push,C
	set push,A
	set A,[start_mem]
	set C,[start_mem]
	:realloc_boucle
		ifg C,peek
			set pc,realloc_found
		set A,C
		add C,[C+1]
		set pc,realloc_boucle
	:realloc_found
		add SP,1
		set push,B
		ifl B,[A+1]
			set pc,realloc_down
		ife [C],0xFFFF
			set pc,realloc_up
	:realloc_malloc
		set push,A
		set push,Z
		set A,B
		jsr malloc
		ife Z,0xFFFF
		set pc,realloc_error
	:realloc_fin
		set C,pick 1
		set C,[C+1]
		sub C,2
		set B,Z
		set Z,pop
		set A,pop
		add A,2
		set push,A
		set A,B
		set B,pop
		jsr memcpy
		set push,A
		set A,B
		jsr free
		set A,pop
		set B,pop
		set C,pop
		set pc,pop
	:realloc_error
		set B,pop
		set C,pop
		set A,0xFFFF
		set pc,pop
	:realloc_up
		ifl [C+1],B
			set pc,realloc_malloc
		sub B,[A+1]
		;B contient la taille necessaire
		set push,A
		set push,Z
		set A,B
		jsr malloc
		set Z,pop
		set A,pop
		add [A+1],B
		add [A+1],2
		set B,pop
		set C,pop
		set pc,pop
	:realloc_down
		set push,A
		sub [A+1],B
		add A,[A+1]
		set [A],[currently_running]
		set [A+1],B
		jsr free
		set A,pop
		set B,pop
	set C,pop
	
	set pc,pop
